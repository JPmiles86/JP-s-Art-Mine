// ImageGrid.tsx
import React, { useContext, useEffect, useState, useRef } from 'react';
import { useNavigate, useParams } from 'react-router-dom';
import styles from './ImageGrid.module.css';
import { DataService, Series } from '../utils/DataService';
import ScrollContext from '../ScrollContext'; 
import useStore, { Store, GridHeaderData, Photograph } from '../utils/store';
import urlConfig from './urlConfig';  // Add this line
import { fetchPhotos } from '../utils/fetchPhotosService';

interface RouteParams {
  filter?: string;
  [key: string]: string | undefined;
}

// Implementing Lazy Loading Feature
// For the lazy loading feature, we'll handle this within your component that renders the photos. 
// The idea is to load a set number of photos initially and load more as needed, such as when the user scrolls.
// We will want to load 33 at a time. And here's the code that used to be in the store file that handled this... 
//  After fetching and sorting all photos, load the first set
// set((state) => {
//  const firstSet = state.sortedPhotos.slice(0, 33);
//  return { ...state, loadedPhotos: firstSet, loadIndex: 33 };
// });

const ImageGrid: React.FC = () => {
  const scrollContainerRef = useRef<HTMLDivElement | null>(null);
  const [series, setSeries] = useState<Series[]>([]);
  const [loading, setLoading] = useState(false);
  const { filter } = useParams<RouteParams>();
  const { 
    previousFilter, 
    setPreviousFilter, 
    seriesFilter, 
    setSeriesFilter, 
    gridHeaderData, 
    setSortValue, 
    fetchGridHeaderData, 
    sortedPhotos, 
    clearPhotos, 
    setCurrentFilter, 
    setPhotosError,
    setLoadingPhotos,
    setPhotos,
    setSortedPhotos,
    setInitialPhotoFetch,
    currentFilter,
    sortValue,
    initialPhotoFetch } = useStore();
  const navigate = useNavigate();  
  const [scrollPos, setScrollPos] = useState(0);  
  const { handleScroll, scrollToTop } = useContext(ScrollContext);  // Access handleScroll
  const { loadedPhotos, loadMorePhotos, photos, loadingPhotos, photosError } = useStore((state) => ({
    loadedPhotos: state.loadedPhotos,
    loadMorePhotos: state.loadMorePhotos,
    photos: state.photos,
    loadingPhotos: state.loadingPhotos,
    photosError: state.photosError
}));


     
  useEffect(() => {
    const dataService = new DataService();
    dataService.fetchAllSeries()
      .then(fetchedSeries => {
        setSeries(fetchedSeries);
      })
      .catch(error => console.error('Error fetching series:', error));
  }, []);  
  
  useEffect(() => {
    console.log('seriesFilter changed:', seriesFilter);
  }, [seriesFilter]);

//  useEffect(() => {
//    // If there are no loaded photos and the photos array is empty, fetch new photos
//    if (loadedPhotos.length === 0 && photos.length === 0) {
//      fetchPhotos();
//    }
//    // If there are loaded photos, use them directly
//    else if (loadedPhotos.length > 0) {
//    }
//  }, [loadedPhotos, fetchPhotos, photos]);

  // Use the fetchPhotos function directly from the service file
  useEffect(() => {
    if (loadedPhotos.length === 0 && photos.length === 0) {
        // Pass necessary functions and states as arguments
        fetchPhotos(
            setCurrentFilter, 
            setPhotosError,
            setLoadingPhotos,
            setPhotos,
            setSortedPhotos,
            setInitialPhotoFetch,
            currentFilter,
            sortValue,
            initialPhotoFetch
        );
    }
}, [loadedPhotos, photos, setCurrentFilter, setPhotosError, setLoadingPhotos, setPhotos, setSortedPhotos, setInitialPhotoFetch, currentFilter, sortValue, initialPhotoFetch]);

// Handle changes in series filter
  useEffect(() => {
    if (filter && filter !== previousFilter) {
      clearPhotos(); // Clear the old data
      setSeriesFilter(filter);
      fetchGridHeaderData(filter) // Fetch header data based on filter
        .catch((error: any) => console.error('Error fetching header data:', error));
      setPreviousFilter(filter);
    }
  }, [filter, previousFilter, setPreviousFilter, setSeriesFilter, fetchGridHeaderData, clearPhotos]);

  useEffect(() => {
    if (filter && filter !== previousFilter) {
      clearPhotos(); // Clear the old data
      setSeriesFilter(filter);
      fetchGridHeaderData(filter)
        .catch((error: any) => console.error('Error fetching header data:', error));
      
      // Call fetchPhotos with required arguments
      fetchPhotos(
        setCurrentFilter, // replace these with actual functions and states from your store
        setPhotosError,
        setLoadingPhotos,
        setPhotos,
        setSortedPhotos,
        setInitialPhotoFetch,
        currentFilter,
        sortValue,
        initialPhotoFetch
      ).then(() => {
        console.log('Photos after fetch:', loadedPhotos);
        setLoading(false); // Set loading to false after fetching new data
      });
      
      setPreviousFilter(filter);
    }
  }, [filter, previousFilter, setPreviousFilter, setSeriesFilter, fetchGridHeaderData, clearPhotos, setCurrentFilter, setPhotosError, setLoadingPhotos, setPhotos, setSortedPhotos, setInitialPhotoFetch, currentFilter, sortValue, initialPhotoFetch, loadedPhotos]);  
  
  useEffect(() => {
    console.log('loadedPhotos after fetch:', loadedPhotos);
  }, [loadedPhotos]);  

  const handleSortChange = (event: React.ChangeEvent<HTMLSelectElement>) => {
    const newSortOrder = event.target.value as 'newest' | 'oldest' | 'random';
    setSortValue(newSortOrder); // Update the sortValue in the global state when the dropdown changes
  };

  const handleSeriesChange = (event: React.ChangeEvent<HTMLSelectElement>) => {
    const newSeriesCode = event.target.value;
    setSeriesFilter(newSeriesCode);
    navigate(`/${newSeriesCode}`);
  };  

  // Handle loading indicator and error messages
if (loadingPhotos) {
  return <div>Loading...</div>;
}

if (photosError) {
  return <div>Error: {photosError}</div>;
}

  if (loading) {
    return <div>Loading...</div>; // Replace this with your actual loading component
  } else {return (
    <div id="scrollable-container" ref={scrollContainerRef}>
   <header className={styles.header}>
     <div className={styles.headerContent}>
       {gridHeaderData && (
         <>
           {
    gridHeaderData && (
        <>
            {console.log(gridHeaderData.imageUrl)}
            {console.log('Image URL:', gridHeaderData.imageUrl)}
            <img src={`${urlConfig.baseURL}${gridHeaderData.imageUrl.slice(gridHeaderData.imageUrl.indexOf('originals') + 'originals'.length)}`} alt="Header" className={styles.circularImage} />
        </>
    )
}
           <div className={styles.titleAndText}>
             <h1>{gridHeaderData.title}</h1>
             <p>{gridHeaderData.description}</p>
             <div className={styles.websiteLink}>
               <a href="https://www.jpmilesfineart.com/" target="_blank" rel="noopener noreferrer">jpmilesfineart.com</a>
             </div>
           </div>
         </>
       )}
     </div>
     <div style={{ display: 'flex', alignItems: 'center' }}>
       <p style={{ marginRight: '10px' }}>Sort By:</p> 
       <select value={sortValue} onChange={handleSortChange} style={{ fontFamily: 'EB Garamond' }}>
         <option value="newest">Newest</option>
         <option value="oldest">Oldest</option>
         <option value="random">Random</option>
       </select>
       {filter && filter.length <= 3 && (
         <>
           <p style={{ marginRight: '10px', marginLeft: '30px' }}>Sort By Series:</p> 
           <select value={seriesFilter} onChange={handleSeriesChange} style={{ fontFamily: 'EB Garamond' }}>
           {series.map((series: Series) => <option key={series.seriesCode} value={series.seriesCode}>{series.seriesName}</option>)}
           </select>
         </>
       )}
     </div>
   </header>
      <div style={{ marginBottom: '20px' }} /> {/* Add this line for a gap */}
      <div className={styles.grid}>
      {!loading && loadedPhotos.map((photo: Photograph, index: number) => (
    <div
      key={photo.photoID}
      className={styles.gridItem} 
      onClick={() => { 
        console.log('Navigating with state:', { data: { loadedPhotos } }); 
        navigate(`/${filter}/${photo.photoID}`, { state: { data: { loadedPhotos } }});
      }}      
    >
      {photo.imagePath && 
        <img 
          src={`${urlConfig.baseURL}${photo.imagePath.slice(photo.imagePath.indexOf('originals') + 'originals'.length)}`} 
          alt="Grid Item" 
          className={styles.image} 
        />
      }
    </div>
  ))}
</div>
      <footer>
        The Art Mine
        <a href="#top" className={styles.arrowLink}>↑</a>
      </footer>
      <button onClick={scrollToTop} className={styles.scrollToTopButton}>
        ↑
      </button>
    </div>
  );
}
}
export default ImageGrid;