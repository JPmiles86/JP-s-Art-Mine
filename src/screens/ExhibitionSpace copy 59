// my-gallery/src/screens/ExhibitionSpace.tsx
import React, { useMemo, useRef, useState, useEffect, useCallback } from 'react';
import { useLocation, useParams, useNavigate } from 'react-router-dom';
import styles from './ExhibitionSpace.module.css';
import useStore from './store';
import ExhibitionHeader from './ExhibitionHeader';
import GalleryBackgroundSelector from './GalleryBackgroundSelector';
import useKeyboardNavigation from './useKeyboardNavigation';
import { diptychComponentRegistry } from '../Diptychs/diptychRegistry';
import { fabric } from 'fabric';
import useGalleryNavigation from '../utils/useGalleryNavigation';
import { generateDiptychIdCode, loadComponent } from '../Diptychs/DiptychDynamicUtils';


interface Photograph {
  photoID: string;
  number: string;
  url: string;
  imagePath?: string;
  aspectRatio: string;
  title: string;
  date: string;
  dateOriginal: string;
  index?: number;
  seriesName: string;
  seriesCode: string;
}

const ExhibitionSpace = () => {
  const navigate = useNavigate();
  const { photoID } = useParams<{ photoID: string }>();
  const { photos, fetchPhotos, selectedPhoto, setSelectedPhoto, loading } = useStore((state) => state);
  // State to track the current index of the selected photo in the sortedPhotos array
  const [currentIndex, setCurrentIndex] = useState(0);
  const [galleryBackground, setGalleryBackground] = useState('/assets/images/gallerybg/Gallery-2.png');
  const [error] = useState<Error | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const location = useLocation();
  const currentFilter = location.pathname.split('/')[1];
  const currentPhotoID = location.pathname.split('/')[2];
  const { sortedPhotos, setPreviousFilter } = useStore();
  const [DiptychComponent, setDiptychComponent] = useState<React.ComponentType<any> | null>(null);
  const [frameColor, setFrameColor] = useState<number>(1);
  const [isMerged, setIsMerged] = useState<string>('entangled');
  const [shapeCode, setShapeCode] = useState<string>('CD');
  const [diptychIdCode, setDiptychIdCode] = useState('');
  const [diptychInfo, setDiptychInfo] = useState<any>(null);
  const [diptychLoading, setDiptychLoading] = useState(true);
  const [diptychInfoLoading, setDiptychInfoLoading] = useState(true);
  const [isContainerReady, setIsContainerReady] = useState(false);
   // Ref for the main gallery container, used to check its size for layout purposes
  const galleryRef = useRef<HTMLDivElement | null>(null);
   // Ref for the container of the DiptychComponent, used in canvas sizing and positioning
  const containerRef = useRef<HTMLDivElement>(null);
  const [isPreloadingNextDiptych, setIsPreloadingNextDiptych] = useState(false);
  const [preloadedDiptychComponent, setPreloadedDiptychComponent] = useState<React.ComponentType<any> | null>(null);
  const [isPhotoSelected, setIsPhotoSelected] = useState(false);
  const [isDiptychInfoLoaded, setIsDiptychInfoLoaded] = useState(false);
  const [isGalleryBackgroundReady, setIsGalleryBackgroundReady] = useState(false);
  const [currentComponent, setCurrentComponent] = useState<React.ComponentType<any> | null>(null);
  const [nextComponent, setNextComponent] = useState<React.ComponentType<any> | null>(null);
  const CurrentComponent = currentComponent;
  const NextComponent = nextComponent;
  const [isNextComponentLoaded, setIsNextComponentLoaded] = useState(false);
  const { handlePrevPhoto, handleNextPhoto } = useGalleryNavigation(sortedPhotos, setSelectedPhoto);
  // Define wrapped functions that don't take any parameters
  const wrappedHandlePrevPhoto = () => handlePrevPhoto(currentIndex);
  const wrappedHandleNextPhoto = () => handleNextPhoto(currentIndex);

  // useMemo to memoize the background image style
  const galleryBackgroundStyle = useMemo(() => ({
    backgroundImage: `url(${galleryBackground})`,
    display: 'flex',
    justifyContent: 'center',
    alignItems: 'center',
  }), [galleryBackground]);

    // Callback when the Diptych canvas is ready, can add additional setup here if needed
  const onCanvasReady = useCallback((canvasRef: fabric.Canvas, diptychIdCode: string) => {
    console.log(`Canvas ready for ${diptychIdCode}`, canvasRef);
  }, []);
  
  const handleChangeGalleryBackground = useCallback((backgroundImage: string) => {
    setGalleryBackground(backgroundImage);
  }, [setGalleryBackground]);  

  const swapMapping: { [key: string]: string } = {
    'CD': 'SD',
    'SD': 'CD',
    'DS': 'TS',
    'TS': 'DS',
    'ST': 'CT',
    'CT': 'ST',
    'TC': 'DC',
    'DC': 'TC',
  };

  const rotateMapping: { [key: string]: string } = {
    'CD': 'DS',
    'DS': 'ST',
    'ST': 'TC',
    'TC': 'CD',
    'SD': 'DC',
    'DC': 'CT',
    'CT': 'TS',
    'TS': 'SD',
  };

  const handleBackToImageGrid = () => {
    setPreviousFilter(currentFilter);
    navigate(`/${currentFilter}`);
  };

  const changeFrameColor = useCallback(() => {
    if (!isLoading && !diptychInfoLoading && selectedPhoto) {
      const nextFrameColor = frameColor === 1 ? 2 : 1;
      setFrameColor(nextFrameColor);
      const newDiptychIdCode = generateDiptychIdCode(selectedPhoto, isMerged, nextFrameColor, shapeCode);
      setIsPreloadingNextDiptych(true);
      loadComponent(newDiptychIdCode, setNextComponent, setIsPreloadingNextDiptych, setIsNextComponentLoaded);

    }
  }, [isLoading, diptychInfoLoading, selectedPhoto, frameColor, isMerged, shapeCode]);  

  const toggleMergeStatus = useCallback(() => {
    if (!isLoading && !diptychInfoLoading && selectedPhoto) {
      const nextMergeStatus = isMerged === 'entangled' ? 'fused' : 'entangled';
      setIsMerged(nextMergeStatus);
      const newDiptychIdCode = generateDiptychIdCode(selectedPhoto, nextMergeStatus, frameColor, shapeCode);
      setIsPreloadingNextDiptych(true);
      loadComponent(newDiptychIdCode, setNextComponent, setIsPreloadingNextDiptych, setIsNextComponentLoaded);
    }
  }, [isLoading, diptychInfoLoading, selectedPhoto, isMerged, frameColor, shapeCode]);  
  
  const swapShape = useCallback(() => {
    if (!isLoading && !diptychInfoLoading && selectedPhoto) {
      const nextShapeCode = swapMapping[shapeCode];
      setShapeCode(nextShapeCode);
      const newDiptychIdCode = generateDiptychIdCode(selectedPhoto, isMerged, frameColor, nextShapeCode);
      setIsPreloadingNextDiptych(true);
      loadComponent(newDiptychIdCode, setNextComponent, setIsPreloadingNextDiptych, setIsNextComponentLoaded);
    }
  }, [isLoading, diptychInfoLoading, selectedPhoto, shapeCode, frameColor, isMerged]);
  
  const rotateShape = useCallback(() => {
    if (!isLoading && !diptychInfoLoading && selectedPhoto) {
      const nextShapeCode = rotateMapping[shapeCode];
      setShapeCode(nextShapeCode);
      const newDiptychIdCode = generateDiptychIdCode(selectedPhoto, isMerged, frameColor, nextShapeCode);
      setIsPreloadingNextDiptych(true);
      loadComponent(newDiptychIdCode, setNextComponent, setIsPreloadingNextDiptych, setIsNextComponentLoaded);
    }
  }, [isLoading, diptychInfoLoading, selectedPhoto, shapeCode, frameColor, isMerged]);
  

  
  
  
  
  // This effect handles preloading the next diptych component
  useEffect(() => {
    if (isPreloadingNextDiptych && diptychIdCode) {
      const Component = diptychComponentRegistry[diptychIdCode];
      if (Component) {
        const MemoizedComponent = React.memo(Component);
        setNextComponent(() => MemoizedComponent);
      } else {
        console.error('Diptych component not found in registry:', diptychIdCode);
        setNextComponent(null);
      }
    }
  }, [diptychIdCode, isPreloadingNextDiptych]);

  // This effect handles swapping the current diptych component with the preloaded one
  useEffect(() => {
    if (nextComponent && !isPreloadingNextDiptych) {
      console.log('Swapping to the preloaded component');
      setCurrentComponent(nextComponent);
      setNextComponent(null);
      setIsPreloadingNextDiptych(false); // This line indicates the preload dance has ended
    }
  }, [nextComponent, isPreloadingNextDiptych]);

// Fetch photos from the backend when the component mounts or the 'photos' array changes
  useEffect(() => {
    if (photos.length === 0) {
      fetchPhotos();
    } else {
      // As soon as photos are fetched, we can set the gallery background to ready
      setIsGalleryBackgroundReady(true);
    }
  }, [photos, fetchPhotos]);

  useEffect(() => {
    if (photoID) {
      setSelectedPhoto(photoID);
      setIsPhotoSelected(true); // Set this flag to true once the photo is selected
    } else {
      setIsPhotoSelected(false); // Reset the flag if no photo is selected
    }
  }, [photoID, setSelectedPhoto]);

  // Set the current index to the index of the selected photo in the sortedPhotos array
  useEffect(() => {
    if (sortedPhotos && sortedPhotos.length > 0) {
      const newIndex = sortedPhotos.findIndex((img: Photograph) => img.photoID === photoID);
      setCurrentIndex(newIndex);
      setIsLoading(false);
    } else {
      console.log("Photos are not available yet!");
    }
  }, [photoID, sortedPhotos]);

  useEffect(() => {
    if (selectedPhoto && isPhotoSelected) {
      const diptychIdCode = generateDiptychIdCode(selectedPhoto, isMerged, frameColor, shapeCode);
      if (diptychIdCode) {
        console.log(`Setting DiptychComponent for: ${diptychIdCode}`);
        loadComponent(diptychIdCode, setNextComponent, setIsPreloadingNextDiptych, setIsNextComponentLoaded);
      }
    }
  }, [selectedPhoto, isMerged, frameColor, shapeCode, isPhotoSelected]);  

  // This effect is solely responsible for fetching diptych info.
// It only depends on the diptych ID code.
useEffect(() => {
  if (!diptychIdCode) return; // Don't fetch if there's no ID code.

  setDiptychInfoLoading(true);
  fetch(`/api/diptychsvgs/${diptychIdCode}`)
    .then(response => response.json())
    .then(data => {
      setDiptychInfo(data);
      setIsDiptychInfoLoaded(true);
    })
    .catch(error => {
      console.error('Error fetching diptych info:', error);
      setIsDiptychInfoLoaded(false);
    })
    .finally(() => {
      setDiptychInfoLoading(false);
      setDiptychLoading(false);
    });
}, [diptychIdCode]);

  // UseEffect to check container size
  useEffect(() => {
    const checkContainerSize = () => {
      if (galleryRef.current) {
        const { clientWidth } = galleryRef.current;
        const containerReady = clientWidth > 0;
        console.log("Gallery container width check, isContainerReady:", containerReady, "Width:", clientWidth);
        setIsContainerReady(containerReady);
      }
    };
  
    checkContainerSize();
    window.addEventListener('resize', checkContainerSize);
  
    return () => {
      window.removeEventListener('resize', checkContainerSize);
    };
  }, [selectedPhoto, currentComponent, isLoading]); // Additional temporary dependencies
  
    useKeyboardNavigation(wrappedHandleNextPhoto, wrappedHandlePrevPhoto, swapShape, rotateShape, toggleMergeStatus);

  if (!selectedPhoto || !currentComponent) {
    return <div>No Photo Selected.</div>;
  }

  if (error) {
    return <div>Error: {error.message}</div>;
  }
  
  //if (loading.photos || loading.diptychSVG || loading.diptychInfo || loading.galleryBackground) {
  //  return <div>Loading Exhibition...</div>;
  //}

  console.log('Selected photo in ExhibitionSpace: ', selectedPhoto);
  console.log("Before rendering in ExhibitionSpace, isContainerReady:", isContainerReady, "selectedPhoto:", selectedPhoto);
  console.log("Gallery background image URL:", galleryBackground);
  console.log("Exhbition Space States:", "isContainerReady: ", isContainerReady, "isPhotoSelected:", isPhotoSelected, "isDiptychInfoLoaded:", isDiptychInfoLoaded, "CurrentComponent:", currentComponent, "nextComponent:", nextComponent);

  return (
    <div className={styles.exhibitionSpace}>
      <ExhibitionHeader
        currentFilter={currentFilter}
        selectedPhoto={selectedPhoto}
        diptychInfo={diptychInfo}
        handlePrevPhoto={() => handlePrevPhoto(currentIndex)}
        handleNextPhoto={() => handleNextPhoto(currentIndex)}
      />
      <div ref={galleryRef} className={styles.gallery} style={galleryBackgroundStyle}>
      <div style={{
        width: ['C', 'S'].includes(shapeCode.charAt(0)) ? '45%' : '64%',
        height: ['C', 'S'].includes(shapeCode.charAt(0)) ? '45%' : '64%',
        maxWidth: '800px',
        margin: '0 auto',
      }}>
        {isContainerReady && isPhotoSelected && CurrentComponent && (
          console.log(`Rendering CurrentComponent with photoId: ${selectedPhoto.photoID}, diptychIdCode: ${diptychIdCode}`),
          <CurrentComponent
            photoId={selectedPhoto.photoID}
            containerRef={containerRef}
            onCanvasReady={onCanvasReady}
          />
        )}
        {isContainerReady && isPhotoSelected && NextComponent && (
          console.log(`NextComponent ready with photoId: ${selectedPhoto.photoID}, diptychIdCode: ${diptychIdCode}`),
          <div className={`${styles.invisible} ${styles.diptychComponent}`}>
            <NextComponent
              photoId={selectedPhoto.photoID}
              containerRef={containerRef}
              onCanvasReady={onCanvasReady}
            />
          </div>
        )}

      </div>
    </div>

      <div className={styles.buttonContainer}>
        <button className={styles.frameColorButton} onClick={changeFrameColor}>
          Frame in {frameColor === 1 ? 'Black' : 'White'}
        </button>
        <button className={styles.mergeButton} onClick={toggleMergeStatus}>
          {isMerged === 'entangled' ? 'Merge' : 'Unmerge'}
        </button>
        <button className={styles.swapButton} onClick={swapShape}>
          Swap
        </button>
        <button className={styles.rotateButton} onClick={rotateShape}>
          Rotate
        </button>
        <button className={styles.swapButton} onClick={() => navigate(`/${currentFilter}/${currentPhotoID}/inquire`)}>
          Inquire
        </button>
        <GalleryBackgroundSelector onChange={handleChangeGalleryBackground} />
      </div>
    </div>
  );
};

export default ExhibitionSpace; 